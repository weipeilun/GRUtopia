from typing import List
import numpy as np
import torch
import time
from omni.isaac.core.articulations import ArticulationSubset
from omni.isaac.core.utils.types import ArticulationAction
from omni.isaac.core.scenes import Scene
from omni.isaac.sensor import Camera

import grutopia.core.util.gym as gymutil
import grutopia.core.util.math as math_utils
from grutopia.core.robot.controller import BaseController
from grutopia.core.robot.robot import BaseRobot
from grutopia.core.robot.robot_model import ControllerModel
from grutopia.core.util.rsl_rl import pickle


@BaseController.register('TrainPPOController')
class TrainPPOController(BaseController):
    """Traning class using locomotion speed to control joint positions for H1 robot."""

    def __init__(self, config: ControllerModel, robot: BaseRobot, scene: Scene) -> None:
        super().__init__(config=config, robot=robot, scene=scene)

        # todo: config
        self.num_actions = 19
        self.joint_subset = None
        self.joint_names = config.joint_names
        if self.joint_names is not None:
            self.joint_subset = ArticulationSubset(self.robot.isaac_robot, self.joint_names)
        self.applied_joint_positions = np.zeros(self.num_actions, dtype=np.float32)
        self._apply_times_left = 0  # Specifies how many times the action generated by the policy needs to be repeatedly applied.

    def forward(
        self,
        joint_positions
    ) -> ArticulationAction:
        if self._apply_times_left > 0:
            self._apply_times_left -= 1
            if self.joint_subset is None:
                return ArticulationAction(joint_positions=self.applied_joint_positions)
            return self.joint_subset.make_articulation_action(joint_positions=self.applied_joint_positions,
                                                              joint_velocities=None)

        self.applied_joint_positions = joint_positions
        self._apply_times_left = self.robot.user_config.per_inference_frames - 1

        if self.joint_subset is None:
            return ArticulationAction(joint_positions=self.applied_joint_positions)
        return self.joint_subset.make_articulation_action(joint_positions=self.applied_joint_positions,
                                                          joint_velocities=None)

    def action_to_control(self, action: List | np.ndarray) -> ArticulationAction:
        """Convert input action (in 1d array format) to joint positions to apply.

        Args:
            action (List | np.ndarray): 3-element 1d array containing:
              0. forward_speed (float)
              1. lateral_speed (float)
              2. rotation_speed (float)

        Returns:
            ArticulationAction: joint positions to apply.
        """
        assert len(action) == self.num_actions, 'action must contain 3 elements'

        return self.forward(action)

    def get_obs(self, *args, **kwargs):
        return self.applied_joint_positions
